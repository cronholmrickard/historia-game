<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flashcards – Medeltiden</title>
    <style>
      :root {
        --bg: #0b0f14;
        --card: #121922;
        --muted: #9db2c7;
        --text: #e6edf3;
        --accent: #4da3ff;
        --good: #1db954;
        --bad: #ff6464;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        background: #0b0f14;
        color: var(--text);
        overflow-x: hidden; /* ban horizontal scroll */
        overflow-y: auto; /* allow vertical scroll */
        overscroll-behavior-y: contain;
      }
      .wrap {
        max-width: 900px;
        margin: 0 auto;
        padding: 18px;
        min-height: 100dvh; /* allow content to grow for vertical scroll */
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-width: 0;
      }
      h1 {
        margin: 0 0 12px 0;
        font-size: 18px;
      }
      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 12px;
      }
      select,
      button {
        background: #0f1722;
        border: 1px solid #223247;
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
      }
      button {
        cursor: pointer;
      }
      .card {
        background: var(--card);
        border: 1px solid #223247;
        border-radius: 16px;
        padding: 24px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      .card.score-card {
        background: #ffffff;
        color: #0b0f14;
        border-color: #e5e7eb;
      }
      .cards-row {
        display: flex;
        gap: 12px;
        align-items: stretch;
        flex: 1 1 auto;
        min-height: 0;
      }
      .cards-row > .card {
        min-width: 0;
      }
      @media (max-width: 700px) {
        .cards-row {
          flex-direction: column;
        }
        .match .cols {
          grid-template-columns: 1fr;
        }
        .term {
          font-size: 18px;
        }
        .def {
          font-size: 12px;
        }
      }
      .score-left .progress {
        width: min(160px, 100%);
      }
      .score-wrap {
        display: flex;
        align-items: center;
        gap: 16px;
        justify-content: space-between;
        flex-wrap: wrap;
      }
      .score-left {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }
      .score-right img {
        width: 96px;
        height: 96px;
        border-radius: 12px;
        border: 1px solid #e5e7eb;
        background: #fff;
        object-fit: contain; /* avoid cropping */
      }
      .score-left small {
        color: #475569;
      }
      .pie {
        width: 96px;
        height: 96px;
        display: block;
      }
      .pie .bg {
        fill: none;
        stroke: #e5e7eb;
        stroke-width: 10;
      }
      .pie .fg {
        fill: none;
        stroke: var(--accent);
        stroke-width: 10;
        stroke-linecap: round;
        transform: rotate(-90deg);
        transform-origin: 50% 50%;
      }
      .flash {
        min-height: 220px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        justify-content: center;
        text-align: center;
        flex: 1 1 auto;
        min-width: 0;
      }
      .flash.matching {
        align-items: stretch;
        justify-content: flex-start;
      }
      .term {
        font-size: 18px;
        font-weight: 800;
      }
      .def {
        font-size: 14px;
        color: var(--muted);
      }
      .hidden {
        display: none;
      }
      .match {
        width: 100%;
        align-self: stretch;
        max-height: 100%;
      }
      .flash.matching .match {
        overflow: auto;
      }
      .match .cols {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      .match .col {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 0;
      }
      .chip {
        display: block;
        width: 100%;
        max-width: 100%;
        padding: 12px 14px;
        border-radius: 12px;
        background: #0f1722;
        border: 1px solid #223247;
        color: var(--text);
        text-align: left;
        white-space: normal;
        word-break: break-word;
        font-size: 16px;
        line-height: 1.3;
      }
      .chip.sel {
        outline: none;
        box-shadow: 0 0 0 2px var(--accent);
      }
      .chip.ok {
        background: #11301f;
        border-color: #1f7a43;
        color: #b7ffd3;
      }
      #match:not(.hidden) ~ #controls {
        display: none !important;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .btn-accent {
        background: var(--accent);
        color: #001428;
        border-color: #2a7fd6;
      }
      .btn-good {
        background: var(--good);
        border-color: #169b43;
      }
      .btn-bad {
        background: var(--bad);
        border-color: #c94b4b;
      }
      .progress {
        height: 8px;
        background: #0e1520;
        border: 1px solid #1b2a3c;
        border-radius: 999px;
        overflow: hidden;
        margin-top: 8px;
      }
      .progress > div {
        height: 100%;
        background: linear-gradient(90deg, var(--good), #49e39f);
        width: 0%;
      }
      small {
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Flashcards – Medeltiden</h1>
      <div class="toolbar">
        <button id="newRound">Ny omgång</button>
      </div>

      <div class="cards-row">
        <div class="card" id="qcard" style="flex: 1 1 60%">
          <div class="flash" id="flash">
            <div class="term" id="front">—</div>
            <div class="def" id="back">—</div>
            <div id="match" class="match hidden">
              <div class="cols">
                <div class="col" id="matchTerms"></div>
                <div class="col" id="matchDefs"></div>
              </div>
            </div>
            <div class="row" id="controls">
              <button id="wrong" class="btn-bad">Fel</button>
              <button id="good" class="btn-good">Rätt</button>
            </div>
          </div>
        </div>
        <div class="card score-card" style="flex: 1 1 40%">
          <div class="score-wrap">
            <div class="score-left">
              <svg
                id="accPie"
                class="pie"
                viewBox="0 0 80 80"
                aria-label="Träff"
              >
                <circle class="bg" cx="40" cy="40" r="34" />
                <circle
                  class="fg"
                  cx="40"
                  cy="40"
                  r="34"
                  stroke-dasharray="0 213.6"
                />
              </svg>
              <div class="progress" style="width: 160px">
                <div id="bar"></div>
              </div>
              <small>Kvar: <span id="left">0</span></small>
            </div>
            <div class="score-right">
              <img id="mood" alt="Humör" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="data.js"></script>
    <script>
      // Storage
      const LS_KEY = "flashcards:progress:v3";
      const progress = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
      // One correct answer to consider a card cleared in this simple mode
      const BOX_MAX = 1;
      function getBox(id) {
        return progress[id]?.box ?? 0;
      }
      function setBox(id, box) {
        progress[id] = { box: Math.max(0, Math.min(BOX_MAX, box)) };
        localStorage.setItem(LS_KEY, JSON.stringify(progress));
      }
      function idFor(c) {
        return (c.section + "|" + c.term).toLowerCase();
      }

      // Build deck
      let deck = (window.DATA || []).flatMap((s) =>
        s.cards.map((c) => ({
          ...c,
          section: s.section,
          id: idFor({ ...c, section: s.section }),
        }))
      );
      // True/false questions, loaded from qna.json
      let tfDeck = [];
      let filter = "Alla";
      let queue = []; // sequence of units: {type:'single', card} or {type:'match', cards:[], matched:Set}
      let cursor = 0;
      const MIX_CHANCE = 0.5; // chance to show mismatched definition
      let currentIsMatch = true;
      let currentDefText = "";
      const score = { good: 0, wrong: 0 };
      const GROUP_SIZE = 3;
      const GROUP_PROB = 0.3; // likelihood a unit is a 3-match group if possible
      const MAX_ROUND_ITEMS = 25; // target items per round
      let roundRemaining = 0; // items left in current round (singles count as 1, match counts unresolved pairs)
      let roundTotal = 0; // total items in the current round
      const HAPPY_IMG = "happy.png";
      const SAD_IMG = "sad.png";

      const $ = (sel) => document.querySelector(sel);
      const el = {
        front: $("#front"),
        back: $("#back"),
        qcard: $("#qcard"),
        flash: $("#flash"),
        bar: $("#bar"),
        left: $("#left"),
        good: $("#good"),
        wrong: $("#wrong"),
        newRound: $("#newRound"),
        mood: $("#mood"),
        scoreGood: $("#scoreGood"),
        scoreWrong: $("#scoreWrong"),
        scoreAcc: $("#scoreAcc"),
        match: $("#match"),
        matchTerms: $("#matchTerms"),
        matchDefs: $("#matchDefs"),
        controls: $("#controls"),
      };

      // Load true/false questions and then initialize queue
      fetch("qna.json")
        .then((r) => r.json())
        .then((arr) => {
          tfDeck = (arr || []).map((x, i) => ({
            id: ("tf|" + x.q).toLowerCase(),
            question: x.q,
            answerTrue:
              String(x.a || "")
                .trim()
                .toLowerCase() === "rätt",
          }));
          buildQueue2();
        })
        .catch(() => {});

      // Initial mood image and score
      el.mood.src = HAPPY_IMG;
      updateScore();

      function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function buildQueue() {
        const conceptAll = deck.filter(
          (c) =>
            (filter === "Alla" || c.section === filter) &&
            getBox(c.id) < BOX_MAX
        );
        const tfAll = tfDeck.filter((t) => getBox(t.id) < BOX_MAX);
        const cPool = shuffleArray(conceptAll.slice());
        const tfPool = shuffleArray(tfAll.slice());
        queue = [];
        roundRemaining = 0;
        while (cPool.length || tfPool.length) {
          if (cPool.length >= GROUP_SIZE && Math.random() < GROUP_PROB) {
            const size = Math.min(GROUP_SIZE, cPool.length);
            const group = cPool.splice(0, size);
            queue.push({ type: "match", cards: group, matched: {} });
            roundRemaining += group.length;
          } else {
            if (tfPool.length && (!cPool.length || Math.random() < 0.5)) {
              const q = tfPool.shift();
              queue.push({ type: "tf", q });
              roundRemaining += 1;
            } else if (cPool.length) {
              const card = cPool.shift();
              queue.push({ type: "single", card });
              roundRemaining += 1;
            }
          }
        }
        cursor = 0;
        roundTotal = roundRemaining;
        prepareViewForCurrent();
        update();
      }

      function shuffleQueue() {
        shuffleArray(queue);
      }

      function currentUnit() {
        return queue[cursor];
      }

      // New queue builder limiting rounds to MAX_ROUND_ITEMS and mixing TF
      function buildQueue2() {
        const conceptAll = deck.filter(
          (c) =>
            (filter === "Alla" || c.section === filter) &&
            getBox(c.id) < BOX_MAX
        );
        const tfAll = tfDeck.filter((t) => getBox(t.id) < BOX_MAX);
        const cPool = shuffleArray(conceptAll.slice());
        const tfPool = shuffleArray(tfAll.slice());
        queue = [];
        roundRemaining = 0;
        while (
          (cPool.length || tfPool.length) &&
          roundRemaining < MAX_ROUND_ITEMS
        ) {
          if (
            cPool.length >= GROUP_SIZE &&
            Math.random() < GROUP_PROB &&
            roundRemaining + GROUP_SIZE <= MAX_ROUND_ITEMS
          ) {
            const size = Math.min(
              GROUP_SIZE,
              cPool.length,
              MAX_ROUND_ITEMS - roundRemaining
            );
            const group = cPool.splice(0, size);
            queue.push({ type: "match", cards: group, matched: {} });
            roundRemaining += group.length;
          } else {
            if (tfPool.length && (!cPool.length || Math.random() < 0.5)) {
              const q = tfPool.shift();
              queue.push({ type: "tf", q });
              roundRemaining += 1;
            } else if (cPool.length) {
              const card = cPool.shift();
              queue.push({ type: "single", card });
              roundRemaining += 1;
            } else {
              break;
            }
          }
        }
        cursor = 0;
        roundTotal = roundRemaining;
        prepareViewForCurrent();
        update();
      }

      function update() {
        const unit = currentUnit();
        if (!unit) {
          if (el.qcard) el.qcard.style.display = "none";
          stats();
          return;
        }
        if (el.qcard) el.qcard.style.display = "";
        if (unit.type === "single") {
          el.flash.classList.remove("matching");
          el.match.classList.add("hidden");
          el.controls.classList.remove("hidden");
          el.front.classList.remove("hidden");
          el.back.classList.remove("hidden");
          // 'prepareViewForCurrent' already set currentDefText/currentIsMatch
          el.front.textContent = unit.card.term;
          el.back.textContent = currentDefText || unit.card.definition;
        } else if (unit.type === "tf") {
          el.flash.classList.remove("matching");
          el.match.classList.add("hidden");
          el.controls.classList.remove("hidden");
          el.front.classList.remove("hidden");
          el.back.classList.remove("hidden");
          el.front.textContent = unit.q.question;
          el.back.textContent = "Rätt eller fel?";
        } else if (unit.type === "match") {
          el.flash.classList.add("matching");
          el.controls.classList.add("hidden");
          el.front.classList.add("hidden");
          el.back.classList.add("hidden");
          el.match.classList.remove("hidden");
          renderMatch(unit);
        }
        stats();
      }

      function stats() {
        if (el.left) el.left.textContent = String(roundRemaining);
        const completed = Math.max(0, roundTotal - roundRemaining);
        const pct = roundTotal ? Math.round((completed / roundTotal) * 100) : 0;
        if (el.bar) el.bar.style.width = pct + "%";
      }

      function finishUnit() {
        // remove current unit and move on; if none left, do not auto-start a new round
        if (queue.length === 0) {
          update();
          return;
        }
        queue.splice(cursor, 1);
        if (cursor >= queue.length) cursor = 0;
        prepareViewForCurrent();
        update();
      }
      function prepareViewForCurrent() {
        const unit = currentUnit();
        if (!unit) {
          currentIsMatch = true;
          currentDefText = "";
          return;
        }
        if (unit.type === "single") {
          const pool = deck.filter(
            (x) => filter === "Alla" || x.section === filter
          );
          const canMismatch = pool.length > 1;
          const wantMismatch = canMismatch && Math.random() < MIX_CHANCE;
          if (wantMismatch) {
            let other;
            do {
              other = pool[Math.floor(Math.random() * pool.length)];
            } while (other.id === unit.card.id && pool.length > 1);
            currentIsMatch = other.id === unit.card.id; // if failed to find other when only one card
            currentDefText = other.definition;
          } else {
            currentIsMatch = true;
            currentDefText = unit.card.definition;
          }
        } else if (unit.type === "tf") {
          // no mixing
          currentIsMatch = null;
          currentDefText = "";
        }
      }

      function renderMatch(unit) {
        // Build term buttons
        el.matchTerms.innerHTML = unit.cards
          .map(
            (c) =>
              `<button class="chip term" data-id="${c.id}">${c.term}</button>`
          )
          .join("");
        // Build definition buttons (shuffled)
        const defs = unit.cards.map((c) => ({ id: c.id, t: c.definition }));
        shuffleArray(defs);
        el.matchDefs.innerHTML = defs
          .map(
            (d) => `<button class="chip def" data-id="${d.id}">${d.t}</button>`
          )
          .join("");
        let selected = null;
        const termEls = Array.from(el.matchTerms.querySelectorAll(".term"));
        const defEls = Array.from(el.matchDefs.querySelectorAll(".def"));
        const markMatched = (id) => {
          const t = termEls.find((e) => e.dataset.id === id);
          const d = defEls.find((e) => e.dataset.id === id);
          if (t) {
            t.classList.add("ok");
            t.disabled = true;
          }
          if (d) {
            d.classList.add("ok");
            d.disabled = true;
          }
        };
        termEls.forEach((btn) => {
          btn.addEventListener("click", () => {
            termEls.forEach((b) => b.classList.remove("sel"));
            if (btn.disabled) return;
            selected = btn.dataset.id;
            btn.classList.add("sel");
          });
        });
        defEls.forEach((btn) => {
          btn.addEventListener("click", () => {
            if (!selected || btn.disabled) return;
            const correct = btn.dataset.id === selected;
            if (correct) {
              // score and progress
              score.good++;
              el.mood.src = HAPPY_IMG;
              setBox(selected, 1);
              unit.matched[selected] = true;
              roundRemaining = Math.max(0, roundRemaining - 1);
              markMatched(selected);
              // clear selection state
              termEls.forEach((b) => b.classList.remove("sel"));
              selected = null;
              // If all matched, move to next
              const remainingPairs =
                unit.cards.length - Object.keys(unit.matched).length;
              if (remainingPairs <= 0) {
                finishUnit();
              } else {
                stats();
                updateScore();
              }
            } else {
              score.wrong++;
              el.mood.src = SAD_IMG;
              setBox(selected, 0);
              termEls.forEach((b) => b.classList.remove("sel"));
              selected = null;
              updateScore();
            }
          });
        });
      }
      function mark(type) {
        const unit = currentUnit();
        if (!unit) return;
        if (unit.type === "match") return; // no buttons in match mode
        if (unit.type === "tf") {
          const claimsTrue = type === "good";
          const correct = claimsTrue === !!unit.q.answerTrue;
          if (correct) {
            score.good++;
            el.mood.src = HAPPY_IMG;
            setBox(unit.q.id, 1);
          } else {
            score.wrong++;
            el.mood.src = SAD_IMG;
            setBox(unit.q.id, 0);
          }
          roundRemaining = Math.max(0, roundRemaining - 1);
          updateScore();
          finishUnit();
          return;
        }
        // single mode (term/def)
        const c = unit.card;
        if (!c) return;
        const b = getBox(c.id);
        let nb = b;
        const answeredCorrectly =
          (type === "good" && currentIsMatch) ||
          (type === "wrong" && !currentIsMatch);
        if (answeredCorrectly) {
          nb = b + 1;
          score.good++;
          el.mood.src = HAPPY_IMG;
        } else {
          nb = 0;
          score.wrong++;
          el.mood.src = SAD_IMG;
        }
        setBox(c.id, nb);
        updateScore();
        roundRemaining = Math.max(0, roundRemaining - 1);
        finishUnit();
      }

      function updateScore() {
        const attempts = score.good + score.wrong; // graded attempts
        const acc = attempts ? score.good / attempts : 1; // start at 100%
        // Update pie chart stroke-dasharray based on circumference of r=34 -> ~213.6
        const r = 34;
        const len = 2 * Math.PI * r;
        const dash = Math.max(0, Math.min(len, len * acc));
        const gap = Math.max(0, len - dash);
        const pie = document.querySelector("#accPie .fg");
        if (pie) pie.setAttribute("stroke-dasharray", `${dash} ${gap}`);
      }

      el.good.addEventListener("click", () => mark("good"));
      el.wrong.addEventListener("click", () => mark("wrong"));
      el.newRound.addEventListener("click", () => {
        // Reset progress and start a new mixed, limited round
        localStorage.removeItem(LS_KEY);
        Object.keys(progress).forEach((k) => delete progress[k]);
        score.good = 0;
        score.wrong = 0;
        el.mood.src = HAPPY_IMG;
        updateScore();
        buildQueue2();
      });

      // No keyboard listeners for mobile-focused interaction.

      buildQueue2();
    </script>
  </body>
</html>
