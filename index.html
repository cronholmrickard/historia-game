<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flashcards – Medeltiden</title>
    <style>
      :root {
        --bg: #0b0f14;
        --card: #121922;
        --muted: #9db2c7;
        --text: #e6edf3;
        --accent: #4da3ff;
        --good: #1db954;
        --bad: #ff6464;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        background: #0b0f14;
        color: var(--text);
        overflow-x: hidden; /* ban horizontal scroll */
        overflow-y: auto;   /* allow vertical scroll */
        overscroll-behavior-y: contain;
      }
      .wrap {
        max-width: 900px;
        margin: 0 auto;
        padding: 18px;
        min-height: 100dvh; /* allow content to grow for vertical scroll */
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-width: 0;
      }
      h1 {
        margin: 0 0 12px 0;
        font-size: 18px;
      }
      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 12px;
      }
      select,
      button {
        background: #0f1722;
        border: 1px solid #223247;
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
      }
      button {
        cursor: pointer;
      }
      .card {
        background: var(--card);
        border: 1px solid #223247;
        border-radius: 16px;
        padding: 24px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      .card.score-card {
        background: #ffffff;
        color: #0b0f14;
        border-color: #e5e7eb;
      }
      .cards-row {
        display: flex;
        gap: 12px;
        align-items: stretch;
        flex: 1 1 auto;
        min-height: 0;
      }
      .cards-row > .card { min-width: 0; }
      @media (max-width: 700px) {
        .cards-row {
          flex-direction: column;
        }
        .match .cols { grid-template-columns: 1fr; }
        .term { font-size: 20px; }
        .def { font-size: 15px; }
      }
      .score-left .progress { width: min(160px, 100%); }
      .score-wrap {
        display: flex;
        align-items: center;
        gap: 16px;
        justify-content: space-between;
        flex-wrap: wrap;
      }
      .score-left {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }
      .score-right img {
        width: 96px;
        height: 96px;
        border-radius: 12px;
        border: 1px solid #e5e7eb;
        background: #fff;
        object-fit: contain; /* avoid cropping */
      }
      .score-left small {
        color: #475569;
      }
      .pie {
        width: 96px;
        height: 96px;
        display: block;
      }
      .pie .bg {
        fill: none;
        stroke: #e5e7eb;
        stroke-width: 10;
      }
      .pie .fg {
        fill: none;
        stroke: var(--accent);
        stroke-width: 10;
        stroke-linecap: round;
        transform: rotate(-90deg);
        transform-origin: 50% 50%;
      }
      .flash {
        min-height: 220px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        justify-content: center;
        text-align: center;
        flex: 1 1 auto;
        min-width: 0;
      }
      .flash.matching { align-items: stretch; justify-content: flex-start; }
      .term {
        font-size: 22px;
        font-weight: 800;
      }
      .def {
        font-size: 16px;
        color: var(--muted);
      }
      .hidden { display: none; }
      .match { width: 100%; align-self: stretch; max-height: 100%; }
      .flash.matching .match { overflow: auto; }
      .match .cols { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: start; }
      .match .col { display: flex; flex-direction: column; gap: 8px; min-width: 0; }
      .chip { display: block; width: 100%; max-width: 100%; padding: 12px 14px; border-radius: 12px; background: #0f1722; border: 1px solid #223247; color: var(--text); text-align: left; white-space: normal; word-break: break-word; font-size: 16px; line-height: 1.3; }
      .chip.sel { outline: 2px solid var(--accent); }
      .chip.ok { background: #11301f; border-color: #1f7a43; color: #b7ffd3; }
      #match:not(.hidden) ~ #controls { display: none !important; }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .btn-accent {
        background: var(--accent);
        color: #001428;
        border-color: #2a7fd6;
      }
      .btn-good {
        background: var(--good);
        border-color: #169b43;
      }
      .btn-bad {
        background: var(--bad);
        border-color: #c94b4b;
      }
      .progress {
        height: 8px;
        background: #0e1520;
        border: 1px solid #1b2a3c;
        border-radius: 999px;
        overflow: hidden;
        margin-top: 8px;
      }
      .progress > div {
        height: 100%;
        background: linear-gradient(90deg, var(--good), #49e39f);
        width: 0%;
      }
      small {
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Flashcards – Medeltiden</h1>
      <div class="toolbar">
        <button id="shuffle">Blanda</button>
        <button id="reset">Nollställ framsteg</button>
      </div>

      <div class="cards-row">
        <div class="card" style="flex:1 1 60%">
          <div class="flash" id="flash">
          <div class="term" id="front">—</div>
          <div class="def" id="back">—</div>
          <div id="match" class="match hidden">
            <div class="cols">
              <div class="col" id="matchTerms"></div>
              <div class="col" id="matchDefs"></div>
            </div>
          </div>
          <div class="row" id="controls">
            <button id="wrong" class="btn-bad">Fel</button>
            <button id="good" class="btn-good">Rätt</button>
          </div>
          </div>
        </div>
        <div class="card score-card" style="flex:1 1 40%">
          <div class="score-wrap">
            <div class="score-left">
              <svg id="accPie" class="pie" viewBox="0 0 80 80" aria-label="Träff">
                <circle class="bg" cx="40" cy="40" r="34" />
                <circle class="fg" cx="40" cy="40" r="34" stroke-dasharray="0 213.6" />
              </svg>
              <div class="progress" style="width: 160px"><div id="bar"></div></div>
              <small>Kvar: <span id="left">0</span></small>
            </div>
            <div class="score-right">
              <img id="mood" alt="Humör" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="data.js"></script>
    <script>
      // Storage
      const LS_KEY = "flashcards:progress:v3";
      const progress = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
      // One correct answer to consider a card cleared in this simple mode
      const BOX_MAX = 1;
      function getBox(id) {
        return progress[id]?.box ?? 0;
      }
      function setBox(id, box) {
        progress[id] = { box: Math.max(0, Math.min(BOX_MAX, box)) };
        localStorage.setItem(LS_KEY, JSON.stringify(progress));
      }
      function idFor(c) {
        return (c.section + "|" + c.term).toLowerCase();
      }

      // Build deck
      let deck = (window.DATA || []).flatMap((s) =>
        s.cards.map((c) => ({
          ...c,
          section: s.section,
          id: idFor({ ...c, section: s.section }),
        }))
      );
      let filter = "Alla";
      let queue = []; // sequence of units: {type:'single', card} or {type:'match', cards:[], matched:Set}
      let cursor = 0;
      const MIX_CHANCE = 0.4; // chance to show mismatched definition
      let currentIsMatch = true;
      let currentDefText = "";
      const score = { good: 0, wrong: 0 };
      const GROUP_SIZE = 3;
      const GROUP_PROB = 0.45; // likelihood a unit is a 5-match group if possible
      let roundRemaining = 0; // items left in current round (singles count as 1, match counts unresolved pairs)
      const HAPPY_IMG = 'happy.png';
      const SAD_IMG = 'sad.png';

      const $ = (sel) => document.querySelector(sel);
      const el = {
        front: $("#front"),
        back: $("#back"),
        flash: $("#flash"),
        bar: $("#bar"),
        left: $("#left"),
        good: $("#good"),
        wrong: $("#wrong"),
        shuffle: $("#shuffle"),
        reset: $("#reset"),
        mood: $("#mood"),
        scoreGood: $("#scoreGood"),
        scoreWrong: $("#scoreWrong"),
        scoreAcc: $("#scoreAcc"),
        match: $("#match"),
        matchTerms: $("#matchTerms"),
        matchDefs: $("#matchDefs"),
        controls: $("#controls"),
      };

      // Initial mood image and score
      el.mood.src = HAPPY_IMG;
      updateScore();

      function shuffleArray(arr){
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function buildQueue() {
        const all = deck.filter(
          (c) => (filter === "Alla" || c.section === filter) && getBox(c.id) < BOX_MAX
        );
        const pool = all.slice();
        shuffleArray(pool);
        queue = [];
        roundRemaining = 0;
        while (pool.length) {
          if (pool.length >= GROUP_SIZE && Math.random() < GROUP_PROB) {
            const size = Math.min(GROUP_SIZE, pool.length);
            const group = pool.splice(0, size);
            queue.push({ type: 'match', cards: group, matched: {} });
            roundRemaining += group.length;
          } else {
            const card = pool.shift();
            queue.push({ type: 'single', card });
            roundRemaining += 1;
          }
        }
        cursor = 0;
        prepareViewForCurrent();
        update();
      }

      function shuffleQueue() {
        shuffleArray(queue);
      }

      function currentUnit() {
        return queue[cursor];
      }

      function update() {
        const unit = currentUnit();
        if (!unit) {
          el.front.textContent = "Inga kort";
          el.back.textContent = "";
          el.match.classList.add('hidden');
          el.controls.classList.add('hidden');
          el.front.classList.remove('hidden');
          el.back.classList.remove('hidden');
          stats();
          return;
        }
        if (unit.type === 'single') {
          el.flash.classList.remove('matching');
          el.match.classList.add('hidden');
          el.controls.classList.remove('hidden');
          el.front.classList.remove('hidden');
          el.back.classList.remove('hidden');
          // 'prepareViewForCurrent' already set currentDefText/currentIsMatch
          el.front.textContent = unit.card.term;
          el.back.textContent = currentDefText || unit.card.definition;
        } else if (unit.type === 'match') {
          el.flash.classList.add('matching');
          el.controls.classList.add('hidden');
          el.front.classList.add('hidden');
          el.back.classList.add('hidden');
          el.match.classList.remove('hidden');
          renderMatch(unit);
        }
        stats();
      }

      function stats() {
        const all = deck.filter(
          (c) => filter === "Alla" || c.section === filter
        );
        const doneCt = all.filter((c) => getBox(c.id) >= BOX_MAX).length;
        const tot = all.length;
        if (el.left) el.left.textContent = String(roundRemaining);
        if (el.bar) el.bar.style.width = tot ? Math.round((doneCt / tot) * 100) + "%" : "0%";
      }

      function finishUnit() {
        // remove current unit and move on; if none left, start a new round
        if (queue.length === 0) { buildQueue(); return; }
        queue.splice(cursor, 1);
        if (cursor >= queue.length) cursor = 0;
        if (queue.length === 0) {
          buildQueue();
        } else {
          prepareViewForCurrent();
          update();
        }
      }
      function prepareViewForCurrent() {
        const unit = currentUnit();
        if (!unit) {
          currentIsMatch = true;
          currentDefText = "";
          return;
        }
        if (unit.type === 'single') {
          const pool = deck.filter((x) => (filter === "Alla" || x.section === filter));
          const canMismatch = pool.length > 1;
          const wantMismatch = canMismatch && Math.random() < MIX_CHANCE;
          if (wantMismatch) {
            let other;
            do {
              other = pool[Math.floor(Math.random() * pool.length)];
            } while (other.id === unit.card.id && pool.length > 1);
            currentIsMatch = other.id === unit.card.id; // if failed to find other when only one card
            currentDefText = other.definition;
          } else {
            currentIsMatch = true;
            currentDefText = unit.card.definition;
          }
        }
      }

      function renderMatch(unit) {
        // Build term buttons
        el.matchTerms.innerHTML = unit.cards
          .map((c) => `<button class="chip term" data-id="${c.id}">${c.term}</button>`)
          .join("");
        // Build definition buttons (shuffled)
        const defs = unit.cards.map((c) => ({ id: c.id, t: c.definition }));
        shuffleArray(defs);
        el.matchDefs.innerHTML = defs
          .map((d) => `<button class="chip def" data-id="${d.id}">${d.t}</button>`)
          .join("");
        let selected = null;
        const termEls = Array.from(el.matchTerms.querySelectorAll('.term'));
        const defEls = Array.from(el.matchDefs.querySelectorAll('.def'));
        const markMatched = (id) => {
          const t = termEls.find(e => e.dataset.id === id);
          const d = defEls.find(e => e.dataset.id === id);
          if (t) { t.classList.add('ok'); t.disabled = true; }
          if (d) { d.classList.add('ok'); d.disabled = true; }
        };
        termEls.forEach((btn) => {
          btn.addEventListener('click', () => {
            termEls.forEach(b => b.classList.remove('sel'));
            if (btn.disabled) return;
            selected = btn.dataset.id;
            btn.classList.add('sel');
          });
        });
        defEls.forEach((btn) => {
          btn.addEventListener('click', () => {
            if (!selected || btn.disabled) return;
            const correct = btn.dataset.id === selected;
            if (correct) {
              // score and progress
              score.good++;
              el.mood.src = HAPPY_IMG;
              setBox(selected, 1);
              unit.matched[selected] = true;
              roundRemaining = Math.max(0, roundRemaining - 1);
              markMatched(selected);
              // clear selection state
              termEls.forEach(b => b.classList.remove('sel'));
              selected = null;
              // If all matched, move to next
              const remainingPairs = unit.cards.length - Object.keys(unit.matched).length;
              if (remainingPairs <= 0) {
                finishUnit();
              } else {
                stats();
                updateScore();
              }
            } else {
              score.wrong++;
              el.mood.src = SAD_IMG;
              setBox(selected, 0);
              termEls.forEach(b => b.classList.remove('sel'));
              selected = null;
              updateScore();
            }
          });
        });
      }
      function mark(type) {
        const unit = currentUnit();
        if (!unit || unit.type !== 'single') return; // only for single mode
        const c = unit.card;
        if (!c) return;
        const b = getBox(c.id);
        let nb = b;
        let answeredCorrectly = (type === "good" && currentIsMatch) || (type === "wrong" && !currentIsMatch);
        if (answeredCorrectly) {
          nb = b + 1;
          score.good++;
          el.mood.src = HAPPY_IMG;
        } else {
          nb = 0;
          score.wrong++;
          el.mood.src = SAD_IMG;
        }
        setBox(c.id, nb);
        updateScore();
        // count this item done for the round, advance
        roundRemaining = Math.max(0, roundRemaining - 1);
        finishUnit();
      }

      function updateScore() {
        const attempts = score.good + score.wrong; // graded attempts
        const acc = attempts ? score.good / attempts : 1; // start at 100%
        // Update pie chart stroke-dasharray based on circumference of r=34 -> ~213.6
        const r = 34;
        const len = 2 * Math.PI * r;
        const dash = Math.max(0, Math.min(len, len * acc));
        const gap = Math.max(0, len - dash);
        const pie = document.querySelector('#accPie .fg');
        if (pie) pie.setAttribute('stroke-dasharray', `${dash} ${gap}`);
      }

      el.good.addEventListener("click", () => mark("good"));
      el.wrong.addEventListener("click", () => mark("wrong"));
      el.shuffle.addEventListener("click", () => {
        buildQueue();
      });
      el.reset.addEventListener("click", () => {
        localStorage.removeItem(LS_KEY);
        Object.keys(progress).forEach((k) => delete progress[k]);
        score.good = 0; score.wrong = 0;
        el.mood.src = HAPPY_IMG;
        updateScore();
        buildQueue();
      });

      // No keyboard listeners for mobile-focused interaction.

      buildQueue();
    </script>
  </body>
</html>
